// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: read.sql

package db

import (
	"context"
	"database/sql"
)

const getFileStashURLByID = `-- name: GetFileStashURLByID :one
SELECT id, url, created_at FROM file_stash_url WHERE id = $1
`

type GetFileStashURLByIDRow struct {
	ID        int32        `json:"id"`
	Url       string       `json:"url"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) GetFileStashURLByID(ctx context.Context) (GetFileStashURLByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getFileStashURLByID)
	var i GetFileStashURLByIDRow
	err := row.Scan(&i.ID, &i.Url, &i.CreatedAt)
	return i, err
}

const getInfluxDBConfigurationByID = `-- name: GetInfluxDBConfigurationByID :one
SELECT id, type, database_name, host, port, user, password, organization, ssl_enabled, batch_size, retry_interval, retry_exponential_base, max_retries, max_retry_time, meta_as_tags, single_row_enforcer FROM influxdb_configurations WHERE id = $1
`

func (q *Queries) GetInfluxDBConfigurationByID(ctx context.Context) (InfluxdbConfiguration, error) {
	row := q.db.QueryRowContext(ctx, getInfluxDBConfigurationByID)
	var i InfluxdbConfiguration
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.DatabaseName,
		&i.Host,
		&i.Port,
		&i.User,
		&i.Password,
		&i.Organization,
		&i.SslEnabled,
		&i.BatchSize,
		&i.RetryInterval,
		&i.RetryExponentialBase,
		&i.MaxRetries,
		&i.MaxRetryTime,
		&i.MetaAsTags,
		&i.SingleRowEnforcer,
	)
	return i, err
}

const getLVMConfByID = `-- name: GetLVMConfByID :one
SELECT id,machine_id , username, minAvailableSpaceGB, maxAvailableSpaceGB FROM lvm_conf WHERE id = $1
`

type GetLVMConfByIDRow struct {
	ID                  int32   `json:"id"`
	MachineID           string  `json:"machine_id"`
	Username            string  `json:"username"`
	Minavailablespacegb float64 `json:"minavailablespacegb"`
	Maxavailablespacegb float64 `json:"maxavailablespacegb"`
}

func (q *Queries) GetLVMConfByID(ctx context.Context) (GetLVMConfByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getLVMConfByID)
	var i GetLVMConfByIDRow
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.Username,
		&i.Minavailablespacegb,
		&i.Maxavailablespacegb,
	)
	return i, err
}

const getLVStorageIssuerByID = `-- name: GetLVStorageIssuerByID :one
SELECT id, machine_id, hostname, username, minAvailableSpaceGB, maxAvailableSpaceGB FROM lv_storage_issuer WHERE id = $1
`

type GetLVStorageIssuerByIDRow struct {
	ID                  int32   `json:"id"`
	MachineID           string  `json:"machine_id"`
	Hostname            string  `json:"hostname"`
	Username            string  `json:"username"`
	Minavailablespacegb float64 `json:"minavailablespacegb"`
	Maxavailablespacegb float64 `json:"maxavailablespacegb"`
}

func (q *Queries) GetLVStorageIssuerByID(ctx context.Context) (GetLVStorageIssuerByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getLVStorageIssuerByID)
	var i GetLVStorageIssuerByIDRow
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.Hostname,
		&i.Username,
		&i.Minavailablespacegb,
		&i.Maxavailablespacegb,
	)
	return i, err
}

const getLogicalVolumeByID = `-- name: GetLogicalVolumeByID :one
SELECT lv_id, machine_id, lv_name, vg_name, lv_attr, lv_size FROM logical_volumes WHERE lv_id = $1
`

type GetLogicalVolumeByIDRow struct {
	LvID      int32  `json:"lv_id"`
	MachineID string `json:"machine_id"`
	LvName    string `json:"lv_name"`
	VgName    string `json:"vg_name"`
	LvAttr    string `json:"lv_attr"`
	LvSize    string `json:"lv_size"`
}

func (q *Queries) GetLogicalVolumeByID(ctx context.Context) (GetLogicalVolumeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getLogicalVolumeByID)
	var i GetLogicalVolumeByIDRow
	err := row.Scan(
		&i.LvID,
		&i.MachineID,
		&i.LvName,
		&i.VgName,
		&i.LvAttr,
		&i.LvSize,
	)
	return i, err
}

const getMachineByID = `-- name: GetMachineByID :one
SELECT machine_id, hostname, os_version, ip_address FROM machines WHERE machine_id = $1
`

type GetMachineByIDRow struct {
	MachineID string `json:"machine_id"`
	Hostname  string `json:"hostname"`
	OsVersion string `json:"os_version"`
	IpAddress string `json:"ip_address"`
}

func (q *Queries) GetMachineByID(ctx context.Context) (GetMachineByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getMachineByID)
	var i GetMachineByIDRow
	err := row.Scan(
		&i.MachineID,
		&i.Hostname,
		&i.OsVersion,
		&i.IpAddress,
	)
	return i, err
}

const getMachineConfByID = `-- name: GetMachineConfByID :one
SELECT id, machine_id, hostname, username, passphrase, port_number, password, host_key, folder_path FROM machine_conf WHERE id = $1
`

func (q *Queries) GetMachineConfByID(ctx context.Context) (MachineConf, error) {
	row := q.db.QueryRowContext(ctx, getMachineConfByID)
	var i MachineConf
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.Hostname,
		&i.Username,
		&i.Passphrase,
		&i.PortNumber,
		&i.Password,
		&i.HostKey,
		&i.FolderPath,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, message, created_at FROM notifications WHERE id = $1
`

func (q *Queries) GetNotificationByID(ctx context.Context) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByID)
	var i Notification
	err := row.Scan(&i.ID, &i.Message, &i.CreatedAt)
	return i, err
}

const getPhysicalVolumeByID = `-- name: GetPhysicalVolumeByID :one
SELECT pv_id, machine_id, pv_name, vg_name, pv_fmt, pv_attr, pv_size, pv_free FROM physical_volumes WHERE pv_id = $1
`

type GetPhysicalVolumeByIDRow struct {
	PvID      int32  `json:"pv_id"`
	MachineID string `json:"machine_id"`
	PvName    string `json:"pv_name"`
	VgName    string `json:"vg_name"`
	PvFmt     string `json:"pv_fmt"`
	PvAttr    string `json:"pv_attr"`
	PvSize    string `json:"pv_size"`
	PvFree    string `json:"pv_free"`
}

func (q *Queries) GetPhysicalVolumeByID(ctx context.Context) (GetPhysicalVolumeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPhysicalVolumeByID)
	var i GetPhysicalVolumeByIDRow
	err := row.Scan(
		&i.PvID,
		&i.MachineID,
		&i.PvName,
		&i.VgName,
		&i.PvFmt,
		&i.PvAttr,
		&i.PvSize,
		&i.PvFree,
	)
	return i, err
}

const getRabbitMQConfig = `-- name: GetRabbitMQConfig :one
SELECT conn_url, username, password, created_at FROM rabbit_mq_config
`

type GetRabbitMQConfigRow struct {
	ConnUrl   string       `json:"conn_url"`
	Username  string       `json:"username"`
	Password  string       `json:"password"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) GetRabbitMQConfig(ctx context.Context) (GetRabbitMQConfigRow, error) {
	row := q.db.QueryRowContext(ctx, getRabbitMQConfig)
	var i GetRabbitMQConfigRow
	err := row.Scan(
		&i.ConnUrl,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const getRealtimeLogByID = `-- name: GetRealtimeLogByID :one
SELECT id,machine_id ,log_message, created_at FROM realtime_logs WHERE id = $1
`

type GetRealtimeLogByIDRow struct {
	ID         int32        `json:"id"`
	MachineID  string       `json:"machine_id"`
	LogMessage string       `json:"log_message"`
	CreatedAt  sql.NullTime `json:"created_at"`
}

func (q *Queries) GetRealtimeLogByID(ctx context.Context) (GetRealtimeLogByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getRealtimeLogByID)
	var i GetRealtimeLogByIDRow
	err := row.Scan(
		&i.ID,
		&i.MachineID,
		&i.LogMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getVolumeGroupByID = `-- name: GetVolumeGroupByID :one
SELECT vg_id, machine_id, vg_name, pv_count, lv_count, snap_count, vg_attr, vg_size, vg_free FROM volume_groups WHERE vg_id = $1
`

type GetVolumeGroupByIDRow struct {
	VgID      int32  `json:"vg_id"`
	MachineID string `json:"machine_id"`
	VgName    string `json:"vg_name"`
	PvCount   string `json:"pv_count"`
	LvCount   string `json:"lv_count"`
	SnapCount string `json:"snap_count"`
	VgAttr    string `json:"vg_attr"`
	VgSize    string `json:"vg_size"`
	VgFree    string `json:"vg_free"`
}

func (q *Queries) GetVolumeGroupByID(ctx context.Context) (GetVolumeGroupByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getVolumeGroupByID)
	var i GetVolumeGroupByIDRow
	err := row.Scan(
		&i.VgID,
		&i.MachineID,
		&i.VgName,
		&i.PvCount,
		&i.LvCount,
		&i.SnapCount,
		&i.VgAttr,
		&i.VgSize,
		&i.VgFree,
	)
	return i, err
}

const listFileStashURLs = `-- name: ListFileStashURLs :many
SELECT id, url, created_at FROM file_stash_url ORDER BY created_at DESC
`

type ListFileStashURLsRow struct {
	ID        int32        `json:"id"`
	Url       string       `json:"url"`
	CreatedAt sql.NullTime `json:"created_at"`
}

func (q *Queries) ListFileStashURLs(ctx context.Context) ([]ListFileStashURLsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFileStashURLs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFileStashURLsRow{}
	for rows.Next() {
		var i ListFileStashURLsRow
		if err := rows.Scan(&i.ID, &i.Url, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInfluxDBConfigurations = `-- name: ListInfluxDBConfigurations :many
SELECT id, type, database_name, host, port, user, password, organization, ssl_enabled, batch_size, retry_interval, retry_exponential_base, max_retries, max_retry_time, meta_as_tags, single_row_enforcer FROM influxdb_configurations ORDER BY id
`

func (q *Queries) ListInfluxDBConfigurations(ctx context.Context) ([]InfluxdbConfiguration, error) {
	rows, err := q.db.QueryContext(ctx, listInfluxDBConfigurations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InfluxdbConfiguration{}
	for rows.Next() {
		var i InfluxdbConfiguration
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.DatabaseName,
			&i.Host,
			&i.Port,
			&i.User,
			&i.Password,
			&i.Organization,
			&i.SslEnabled,
			&i.BatchSize,
			&i.RetryInterval,
			&i.RetryExponentialBase,
			&i.MaxRetries,
			&i.MaxRetryTime,
			&i.MetaAsTags,
			&i.SingleRowEnforcer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLVMConfs = `-- name: ListLVMConfs :many
SELECT id, machine_id, username, minAvailableSpaceGB, maxAvailableSpaceGB FROM lvm_conf ORDER BY id
`

type ListLVMConfsRow struct {
	ID                  int32   `json:"id"`
	MachineID           string  `json:"machine_id"`
	Username            string  `json:"username"`
	Minavailablespacegb float64 `json:"minavailablespacegb"`
	Maxavailablespacegb float64 `json:"maxavailablespacegb"`
}

func (q *Queries) ListLVMConfs(ctx context.Context) ([]ListLVMConfsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLVMConfs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLVMConfsRow{}
	for rows.Next() {
		var i ListLVMConfsRow
		if err := rows.Scan(
			&i.ID,
			&i.MachineID,
			&i.Username,
			&i.Minavailablespacegb,
			&i.Maxavailablespacegb,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLVStorageIssuers = `-- name: ListLVStorageIssuers :many
SELECT id, machine_id, hostname, username, minAvailableSpaceGB, maxAvailableSpaceGB FROM lv_storage_issuer ORDER BY id
`

type ListLVStorageIssuersRow struct {
	ID                  int32   `json:"id"`
	MachineID           string  `json:"machine_id"`
	Hostname            string  `json:"hostname"`
	Username            string  `json:"username"`
	Minavailablespacegb float64 `json:"minavailablespacegb"`
	Maxavailablespacegb float64 `json:"maxavailablespacegb"`
}

func (q *Queries) ListLVStorageIssuers(ctx context.Context) ([]ListLVStorageIssuersRow, error) {
	rows, err := q.db.QueryContext(ctx, listLVStorageIssuers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLVStorageIssuersRow{}
	for rows.Next() {
		var i ListLVStorageIssuersRow
		if err := rows.Scan(
			&i.ID,
			&i.MachineID,
			&i.Hostname,
			&i.Username,
			&i.Minavailablespacegb,
			&i.Maxavailablespacegb,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogicalVolumes = `-- name: ListLogicalVolumes :many
SELECT lv_id, machine_id, lv_name, vg_name, lv_attr, lv_size FROM logical_volumes ORDER BY lv_id
`

type ListLogicalVolumesRow struct {
	LvID      int32  `json:"lv_id"`
	MachineID string `json:"machine_id"`
	LvName    string `json:"lv_name"`
	VgName    string `json:"vg_name"`
	LvAttr    string `json:"lv_attr"`
	LvSize    string `json:"lv_size"`
}

func (q *Queries) ListLogicalVolumes(ctx context.Context) ([]ListLogicalVolumesRow, error) {
	rows, err := q.db.QueryContext(ctx, listLogicalVolumes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLogicalVolumesRow{}
	for rows.Next() {
		var i ListLogicalVolumesRow
		if err := rows.Scan(
			&i.LvID,
			&i.MachineID,
			&i.LvName,
			&i.VgName,
			&i.LvAttr,
			&i.LvSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMachineConfs = `-- name: ListMachineConfs :many
SELECT id, machine_id, hostname, username, passphrase, port_number, password, host_key, folder_path FROM machine_conf ORDER BY id
`

func (q *Queries) ListMachineConfs(ctx context.Context) ([]MachineConf, error) {
	rows, err := q.db.QueryContext(ctx, listMachineConfs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MachineConf{}
	for rows.Next() {
		var i MachineConf
		if err := rows.Scan(
			&i.ID,
			&i.MachineID,
			&i.Hostname,
			&i.Username,
			&i.Passphrase,
			&i.PortNumber,
			&i.Password,
			&i.HostKey,
			&i.FolderPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMachines = `-- name: ListMachines :many
SELECT machine_id, hostname, os_version, ip_address FROM machines ORDER BY machine_id
`

type ListMachinesRow struct {
	MachineID string `json:"machine_id"`
	Hostname  string `json:"hostname"`
	OsVersion string `json:"os_version"`
	IpAddress string `json:"ip_address"`
}

func (q *Queries) ListMachines(ctx context.Context) ([]ListMachinesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMachines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMachinesRow{}
	for rows.Next() {
		var i ListMachinesRow
		if err := rows.Scan(
			&i.MachineID,
			&i.Hostname,
			&i.OsVersion,
			&i.IpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, message, created_at FROM notifications ORDER BY created_at DESC
`

func (q *Queries) ListNotifications(ctx context.Context) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, listNotifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(&i.ID, &i.Message, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPhysicalVolumes = `-- name: ListPhysicalVolumes :many
SELECT pv_id, machine_id, pv_name, vg_name, pv_fmt, pv_attr, pv_size, pv_free FROM physical_volumes ORDER BY pv_id
`

type ListPhysicalVolumesRow struct {
	PvID      int32  `json:"pv_id"`
	MachineID string `json:"machine_id"`
	PvName    string `json:"pv_name"`
	VgName    string `json:"vg_name"`
	PvFmt     string `json:"pv_fmt"`
	PvAttr    string `json:"pv_attr"`
	PvSize    string `json:"pv_size"`
	PvFree    string `json:"pv_free"`
}

func (q *Queries) ListPhysicalVolumes(ctx context.Context) ([]ListPhysicalVolumesRow, error) {
	rows, err := q.db.QueryContext(ctx, listPhysicalVolumes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPhysicalVolumesRow{}
	for rows.Next() {
		var i ListPhysicalVolumesRow
		if err := rows.Scan(
			&i.PvID,
			&i.MachineID,
			&i.PvName,
			&i.VgName,
			&i.PvFmt,
			&i.PvAttr,
			&i.PvSize,
			&i.PvFree,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRealtimeLogs = `-- name: ListRealtimeLogs :many
SELECT id,machine_id ,log_message, created_at FROM realtime_logs ORDER BY created_at DESC
`

type ListRealtimeLogsRow struct {
	ID         int32        `json:"id"`
	MachineID  string       `json:"machine_id"`
	LogMessage string       `json:"log_message"`
	CreatedAt  sql.NullTime `json:"created_at"`
}

func (q *Queries) ListRealtimeLogs(ctx context.Context) ([]ListRealtimeLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRealtimeLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRealtimeLogsRow{}
	for rows.Next() {
		var i ListRealtimeLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.MachineID,
			&i.LogMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVolumeGroups = `-- name: ListVolumeGroups :many
SELECT vg_id, machine_id, vg_name, pv_count, lv_count, snap_count, vg_attr, vg_size, vg_free FROM volume_groups ORDER BY vg_id
`

type ListVolumeGroupsRow struct {
	VgID      int32  `json:"vg_id"`
	MachineID string `json:"machine_id"`
	VgName    string `json:"vg_name"`
	PvCount   string `json:"pv_count"`
	LvCount   string `json:"lv_count"`
	SnapCount string `json:"snap_count"`
	VgAttr    string `json:"vg_attr"`
	VgSize    string `json:"vg_size"`
	VgFree    string `json:"vg_free"`
}

func (q *Queries) ListVolumeGroups(ctx context.Context) ([]ListVolumeGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listVolumeGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVolumeGroupsRow{}
	for rows.Next() {
		var i ListVolumeGroupsRow
		if err := rows.Scan(
			&i.VgID,
			&i.MachineID,
			&i.VgName,
			&i.PvCount,
			&i.LvCount,
			&i.SnapCount,
			&i.VgAttr,
			&i.VgSize,
			&i.VgFree,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
